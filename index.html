<!DOCTYPE HTML>
<html>
<meta name="viewport" content="initial-scale=1.0">
<head>
  <meta charset="UTF-8">
  <title>CEDom</title>
  <script src="custom-editable.js"></script>
  <script src="main.js"></script>
</head>

<body>


  <template id="editable-template">
    <slot hidden="true">No slot content</slot>
    <div contenteditable="true" class="editable-template-container">Failed to prefill</div>
  </template>
  <div id="elm"></div>

  <custom-editable>nada</custom-editable>

  <script>
      var app = Elm.Editable.init({
        node: document.getElementById('elm')
        , flags: null
    });


    // var node = document.getElementById("editor");
    // var obs = new MutationObserver(handleMutation);
    // obs.observe(node, {subtree: true, childList: true, attributes: true, characterData: true, attributeOldValue: true, characterDataOldValue: true});

    // var nodeRef = 0;

    // function ensureRef(node, messages) {
    //     if (node && node.elmCERef === undefined) {
    //         node.elmCERef = nodeRef++;
    //         console.log("Assigned ID: ", node.elmCERef);

    //         if (node instanceof Text) {
    //             messages.push({'type': 'NewTextNode', 'data': {'ref': node.elmCERef, 'text': node.data}});
    //         } else
    //         if (node instanceof HTMLElement) {
    //             messages.push({'type': 'NewHtmlNode', 'data': {'ref': node.elmCERef, 'tag': node.nodeName.toLowerCase(), 'attributes': {}}});

    //             if (node.childNodes.length > 0) {
    //                 Array.prototype.forEach.call(node.childNodes, child => ensureRef(child, messages));
    //                 messages.push({'type': 'MutationRecord', 'data' : {'target': node.elmCERef, 'mutation': {'type': 'childList', 'nextSibling': null, 'previousSibling': null, 'removedNodes': [], 
    //                     'addedNodes': Array.prototype.map.call(node.childNodes, node => node.elmCERef)}}});

    //             }
    //         }
    //     }
    // }

    // ensureRef(node, []);

    // function handleMutation(mutations, observer) {
    //     //console.log('Sending update');
    //     var messages = []
    //     var removedNodeRefs = new Set();
    //     // console.log('start loop');
    //     for (var mutation of mutations) {
    //         ensureRef(mutation.target, messages);
    //         var messageJson = {'type': 'MutationRecord', 
    //         'data': {'target': mutation.target.elmCERef, 'mutation': {'type': mutation.type}}};
    //         var mutationJson = messageJson.data.mutation;

    //         // console.log(mutation);
    //         switch (mutation.type) {
    //             case 'attributes': 
    //                 break;
    //             case 'characterData':
    //                 mutationJson.characterValue = mutation.target.data;
    //                 messages.push(messageJson);
    //                 break;
    //             case 'childList':
    //                 ensureRef(mutation.previousSibling, messages);
    //                 mutationJson.previousSibling = mutation.previousSibling ? mutation.previousSibling.elmCERef : null;
    //                 ensureRef(mutation.nextSibling, messages);
    //                 mutationJson.nextSibling = mutation.nextSibling ? mutation.nextSibling.elmCERef : null;

    //                 // It is possible for a node to get initially added as the child of another new node, so it never gets its own presence in addedNodes, 
    //                 // and then to be removed, all before the pile of mutations makes it here.  So we just filter out undefined refs in the removedNodes --
    //                 // Elm never saw them.
    //                 Array.prototype.forEach.call(mutation.removedNodes, node => {if (node.elmCERef !== undefined) {removedNodeRefs.add(node.elmCERef)}});
    //                 mutationJson.removedNodes = Array.prototype.map.call(mutation.removedNodes, node => node.elmCERef).filter(ref => ref !== undefined);

    //                 // Array.prototype.forEach.call(mutationJson.removedNodes, ref => console.log("removed ", ref));

    //                 Array.prototype.forEach.call(mutation.addedNodes, node => ensureRef(node, messages));
    //                 mutationJson.addedNodes = Array.prototype.map.call(mutation.addedNodes, node => node.elmCERef);
    //                 Array.prototype.forEach.call(mutation.addedNodes, node => removedNodeRefs.delete(node.elmCERef));
    //                 // Array.prototype.forEach.call(mutation.addedNodes, node => console.log("added ", node.elmCERef));
    //                 messages.push(messageJson);
    //                 break;
    //             default: 
    //                 //console.log('Unknown mutation type ', mutation.type, mutation);
    //         }
    //     }
    //     // console.log('end loop', messages);
    //     for (removedNodeRef of removedNodeRefs) {
    //         messages.push({'type': 'RemoveNode', 'data': {'ref': removedNodeRef}});
    //     }
    //     app.ports.receiveMessage.send(messages);
    // }


    // app.ports.sendMessage.subscribe(function(data) {
    //     console.log("Got changes", data);
    //     // var node = document.getElementById(data[0]);
    //     // console.log("Node is ", node)
    //     // node.innerHTML = data[1]
    // });



</script>
</body>
</html>
